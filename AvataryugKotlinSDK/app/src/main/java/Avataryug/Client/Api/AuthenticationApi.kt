/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.Avataryug.client.Apis

import Avataryug.Client.AvatarProjectSettings
import com.Avataryug.client.Infrastructure.ApiClient
import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.Avataryug.client.Models.LoginWithAndroidDeviceIDRequest
import com.Avataryug.client.Models.LoginWithAndroidDeviceIDResult
import com.Avataryug.client.Models.LoginWithAppleRequest
import com.Avataryug.client.Models.LoginWithAppleResult
import com.Avataryug.client.Models.LoginWithCustomIDRequest
import com.Avataryug.client.Models.LoginWithCustomIDResult
import com.Avataryug.client.Models.LoginWithEmailAddressRequest
import com.Avataryug.client.Models.LoginWithEmailAddressResult
import com.Avataryug.client.Models.LoginWithFacebookRequest
import com.Avataryug.client.Models.LoginWithFacebookResult
import com.Avataryug.client.Models.LoginWithGoogleRequest
import com.Avataryug.client.Models.LoginWithGoogleResult
import com.Avataryug.client.Models.LoginWithIOSDeviceIDRequest
import com.Avataryug.client.Models.LoginWithIOSDeviceIDResult
import com.Avataryug.client.Models.RegisterUserRequest
import com.Avataryug.client.Models.RegisterUserResult

import com.Avataryug.client.Infrastructure.ApiResponse
import com.Avataryug.client.Infrastructure.ClientException
import com.Avataryug.client.Infrastructure.ClientError
import com.Avataryug.client.Infrastructure.ServerException
import com.Avataryug.client.Infrastructure.ServerError
import com.Avataryug.client.Infrastructure.MultiValueMap
import com.Avataryug.client.Infrastructure.RequestConfig
import com.Avataryug.client.Infrastructure.RequestMethod
import com.Avataryug.client.Infrastructure.ResponseType
import com.Avataryug.client.Infrastructure.Success

/**
 * Represents a collection of functions to interact with the API endpoints
 */

class AuthenticationApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            val id = AvatarProjectSettings.Project_Id
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://$id.avataryugapi.com/client")
        }
    }

    /**
     * Login With Android Device ID
     * Signs the user in using the Android device identifier, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithAndroidDeviceIDRequest  (optional)
     * @return LoginWithAndroidDeviceIDResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginWithAndroidDeviceID(loginWithAndroidDeviceIDRequest: LoginWithAndroidDeviceIDRequest? = null) : LoginWithAndroidDeviceIDResult {
        val localVarResponse = loginWithAndroidDeviceIDWithHttpInfo(loginWithAndroidDeviceIDRequest = loginWithAndroidDeviceIDRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithAndroidDeviceIDResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login With Android Device ID
     * Signs the user in using the Android device identifier, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithAndroidDeviceIDRequest  (optional)
     * @return ApiResponse<LoginWithAndroidDeviceIDResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginWithAndroidDeviceIDWithHttpInfo(loginWithAndroidDeviceIDRequest: LoginWithAndroidDeviceIDRequest?) : ApiResponse<LoginWithAndroidDeviceIDResult?> {
        val localVariableConfig = loginWithAndroidDeviceIDRequestConfig(loginWithAndroidDeviceIDRequest = loginWithAndroidDeviceIDRequest)

        return request<LoginWithAndroidDeviceIDRequest, LoginWithAndroidDeviceIDResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithAndroidDeviceID
     *
     * @param loginWithAndroidDeviceIDRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithAndroidDeviceIDRequestConfig(loginWithAndroidDeviceIDRequest: LoginWithAndroidDeviceIDRequest?) : RequestConfig<LoginWithAndroidDeviceIDRequest> {
        val localVariableBody = loginWithAndroidDeviceIDRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/LoginWithAndroidDeviceID",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login With Apple
     * Signs in the user with a Sign in with Apple identity token.
     * @param loginWithAppleRequest  (optional)
     * @return LoginWithAppleResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginWithApple(loginWithAppleRequest: LoginWithAppleRequest? = null) : LoginWithAppleResult {
        val localVarResponse = loginWithAppleWithHttpInfo(loginWithAppleRequest = loginWithAppleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithAppleResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login With Apple
     * Signs in the user with a Sign in with Apple identity token.
     * @param loginWithAppleRequest  (optional)
     * @return ApiResponse<LoginWithAppleResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginWithAppleWithHttpInfo(loginWithAppleRequest: LoginWithAppleRequest?) : ApiResponse<LoginWithAppleResult?> {
        val localVariableConfig = loginWithAppleRequestConfig(loginWithAppleRequest = loginWithAppleRequest)

        return request<LoginWithAppleRequest, LoginWithAppleResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithApple
     *
     * @param loginWithAppleRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithAppleRequestConfig(loginWithAppleRequest: LoginWithAppleRequest?) : RequestConfig<LoginWithAppleRequest> {
        val localVariableBody = loginWithAppleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/LoginWithApple",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login With Custom ID
     * Signs the user in using a custom unique identifier generated by the Project, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithCustomIDRequest  (optional)
     * @return LoginWithCustomIDResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginWithCustomID(loginWithCustomIDRequest: LoginWithCustomIDRequest? = null) : LoginWithCustomIDResult {
        val localVarResponse = loginWithCustomIDWithHttpInfo(loginWithCustomIDRequest = loginWithCustomIDRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithCustomIDResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login With Custom ID
     * Signs the user in using a custom unique identifier generated by the Project, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithCustomIDRequest  (optional)
     * @return ApiResponse<LoginWithCustomIDResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginWithCustomIDWithHttpInfo(loginWithCustomIDRequest: LoginWithCustomIDRequest?) : ApiResponse<LoginWithCustomIDResult?> {
        val localVariableConfig = loginWithCustomIDRequestConfig(loginWithCustomIDRequest = loginWithCustomIDRequest)

        return request<LoginWithCustomIDRequest, LoginWithCustomIDResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithCustomID
     *
     * @param loginWithCustomIDRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithCustomIDRequestConfig(loginWithCustomIDRequest: LoginWithCustomIDRequest?) : RequestConfig<LoginWithCustomIDRequest> {
        val localVariableBody = loginWithCustomIDRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/LoginWithCustomID",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login With Email Address
     * Signs the user into the AvatarYug account, returning a session identifier that can subsequently be used for API calls which require an authenticated user. Unlike most other login API calls, LoginWithEmailAddress does not permit the creation of new accounts via the CreateAccountFlag. E
     * @param loginWithEmailAddressRequest  (optional)
     * @return LoginWithEmailAddressResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginWithEmailAddress(loginWithEmailAddressRequest: LoginWithEmailAddressRequest? = null) : LoginWithEmailAddressResult {
        val localVarResponse = loginWithEmailAddressWithHttpInfo(loginWithEmailAddressRequest = loginWithEmailAddressRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithEmailAddressResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login With Email Address
     * Signs the user into the AvatarYug account, returning a session identifier that can subsequently be used for API calls which require an authenticated user. Unlike most other login API calls, LoginWithEmailAddress does not permit the creation of new accounts via the CreateAccountFlag. E
     * @param loginWithEmailAddressRequest  (optional)
     * @return ApiResponse<LoginWithEmailAddressResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginWithEmailAddressWithHttpInfo(loginWithEmailAddressRequest: LoginWithEmailAddressRequest?) : ApiResponse<LoginWithEmailAddressResult?> {
        val localVariableConfig = loginWithEmailAddressRequestConfig(loginWithEmailAddressRequest = loginWithEmailAddressRequest)

        return request<LoginWithEmailAddressRequest, LoginWithEmailAddressResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithEmailAddress
     *
     * @param loginWithEmailAddressRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithEmailAddressRequestConfig(loginWithEmailAddressRequest: LoginWithEmailAddressRequest?) : RequestConfig<LoginWithEmailAddressRequest> {
        val localVariableBody = loginWithEmailAddressRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/LoginWithEmailAddress",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login With Facebook
     * Signs the user in using a Facebook access token, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithFacebookRequest  (optional)
     * @return LoginWithFacebookResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginWithFacebook(loginWithFacebookRequest: LoginWithFacebookRequest? = null) : LoginWithFacebookResult {
        val localVarResponse = loginWithFacebookWithHttpInfo(loginWithFacebookRequest = loginWithFacebookRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithFacebookResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login With Facebook
     * Signs the user in using a Facebook access token, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithFacebookRequest  (optional)
     * @return ApiResponse<LoginWithFacebookResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginWithFacebookWithHttpInfo(loginWithFacebookRequest: LoginWithFacebookRequest?) : ApiResponse<LoginWithFacebookResult?> {
        val localVariableConfig = loginWithFacebookRequestConfig(loginWithFacebookRequest = loginWithFacebookRequest)

        return request<LoginWithFacebookRequest, LoginWithFacebookResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithFacebook
     *
     * @param loginWithFacebookRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithFacebookRequestConfig(loginWithFacebookRequest: LoginWithFacebookRequest?) : RequestConfig<LoginWithFacebookRequest> {
        val localVariableBody = loginWithFacebookRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/LoginWithFacebook",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login With Google Account
     * Signs the user in using their Google account credentials
     * @param loginWithGoogleRequest  (optional)
     * @return LoginWithGoogleResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginWithGoogle(loginWithGoogleRequest: LoginWithGoogleRequest? = null) : LoginWithGoogleResult {
        val localVarResponse = loginWithGoogleWithHttpInfo(loginWithGoogleRequest = loginWithGoogleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithGoogleResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login With Google Account
     * Signs the user in using their Google account credentials
     * @param loginWithGoogleRequest  (optional)
     * @return ApiResponse<LoginWithGoogleResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginWithGoogleWithHttpInfo(loginWithGoogleRequest: LoginWithGoogleRequest?) : ApiResponse<LoginWithGoogleResult?> {
        val localVariableConfig = loginWithGoogleRequestConfig(loginWithGoogleRequest = loginWithGoogleRequest)

        return request<LoginWithGoogleRequest, LoginWithGoogleResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithGoogle
     *
     * @param loginWithGoogleRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithGoogleRequestConfig(loginWithGoogleRequest: LoginWithGoogleRequest?) : RequestConfig<LoginWithGoogleRequest> {
        val localVariableBody = loginWithGoogleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/LoginWithGoogle",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login With IOS Device ID
     * Signs the user in using the vendor-specific iOS device identifier, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithIOSDeviceIDRequest  (optional)
     * @return LoginWithIOSDeviceIDResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginWithIOSDeviceID(loginWithIOSDeviceIDRequest: LoginWithIOSDeviceIDRequest? = null) : LoginWithIOSDeviceIDResult {
        val localVarResponse = loginWithIOSDeviceIDWithHttpInfo(loginWithIOSDeviceIDRequest = loginWithIOSDeviceIDRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithIOSDeviceIDResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login With IOS Device ID
     * Signs the user in using the vendor-specific iOS device identifier, returning a session identifier that can subsequently be used for API calls which require an authenticated user
     * @param loginWithIOSDeviceIDRequest  (optional)
     * @return ApiResponse<LoginWithIOSDeviceIDResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginWithIOSDeviceIDWithHttpInfo(loginWithIOSDeviceIDRequest: LoginWithIOSDeviceIDRequest?) : ApiResponse<LoginWithIOSDeviceIDResult?> {
        val localVariableConfig = loginWithIOSDeviceIDRequestConfig(loginWithIOSDeviceIDRequest = loginWithIOSDeviceIDRequest)

        return request<LoginWithIOSDeviceIDRequest, LoginWithIOSDeviceIDResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithIOSDeviceID
     *
     * @param loginWithIOSDeviceIDRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithIOSDeviceIDRequestConfig(loginWithIOSDeviceIDRequest: LoginWithIOSDeviceIDRequest?) : RequestConfig<LoginWithIOSDeviceIDRequest> {
        val localVariableBody = loginWithIOSDeviceIDRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/LoginWithIOSDeviceID",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Register User
     *
     * @param registerUserRequest  (optional)
     * @return RegisterUserResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun registerUser(registerUserRequest: RegisterUserRequest? = null) : RegisterUserResult {
        val localVarResponse = registerUserWithHttpInfo(registerUserRequest = registerUserRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegisterUserResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Register User
     *
     * @param registerUserRequest  (optional)
     * @return ApiResponse<RegisterUserResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun registerUserWithHttpInfo(registerUserRequest: RegisterUserRequest?) : ApiResponse<RegisterUserResult?> {
        val localVariableConfig = registerUserRequestConfig(registerUserRequest = registerUserRequest)

        return request<RegisterUserRequest, RegisterUserResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerUser
     *
     * @param registerUserRequest  (optional)
     * @return RequestConfig
     */
    fun registerUserRequestConfig(registerUserRequest: RegisterUserRequest?) : RequestConfig<RegisterUserRequest> {
        val localVariableBody = registerUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/RegisterUser",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}