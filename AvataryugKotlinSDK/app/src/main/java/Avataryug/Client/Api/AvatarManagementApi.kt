/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.Avataryug.client.Apis

import Avataryug.Client.AvatarProjectSettings
import com.Avataryug.client.Infrastructure.ApiClient
import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.Avataryug.client.Models.GenerateAvatarMeshRequest
import com.Avataryug.client.Models.GenerateAvatarMeshResult
import com.Avataryug.client.Models.GetAllBucketVerticesResult
import com.Avataryug.client.Models.GetAvatarPresetByIDRequest
import com.Avataryug.client.Models.GetAvatarPresetsResult
import com.Avataryug.client.Models.GetClipsByIDResult
import com.Avataryug.client.Models.GetClipsResult
import com.Avataryug.client.Models.GetExpressionByIDResult
import com.Avataryug.client.Models.GetExpressionsResult
import com.Avataryug.client.Models.GrantAvatarPresetItemsToUserRequest
import com.Avataryug.client.Models.GrantAvatarPresetItemsToUserResult
import com.Avataryug.client.Models.GrantAvatarPresetToUserRequest
import com.Avataryug.client.Models.GrantAvatarPresetToUserResult
import com.Avataryug.client.Models.RenderAvatarImageRequest
import com.Avataryug.client.Models.RenderAvatarImageResult
import com.Avataryug.client.Models.SyncAvatarsRequest
import com.Avataryug.client.Models.SyncAvatarsResult

import com.Avataryug.client.Infrastructure.ApiResponse
import com.Avataryug.client.Infrastructure.ClientException
import com.Avataryug.client.Infrastructure.ClientError
import com.Avataryug.client.Infrastructure.ServerException
import com.Avataryug.client.Infrastructure.ServerError
import com.Avataryug.client.Infrastructure.MultiValueMap
import com.Avataryug.client.Infrastructure.RequestConfig
import com.Avataryug.client.Infrastructure.RequestMethod
import com.Avataryug.client.Infrastructure.ResponseType
import com.Avataryug.client.Infrastructure.Success

/**
 * Represents a collection of functions to interact with the API endpoints
 */
class AvatarManagementApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            val id = AvatarProjectSettings.Project_Id
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://$id.avataryugapi.com/client")
        }
    }

    /**
     * Generate Avatar Mesh
     * Generates the 3D mesh as per the configuration in the Config panel
     * @param generateAvatarMeshRequest  (optional)
     * @return GenerateAvatarMeshResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateAvatarMesh(generateAvatarMeshRequest: GenerateAvatarMeshRequest? = null) : GenerateAvatarMeshResult {
        val localVarResponse = generateAvatarMeshWithHttpInfo(generateAvatarMeshRequest = generateAvatarMeshRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenerateAvatarMeshResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate Avatar Mesh
     * Generates the 3D mesh as per the configuration in the Config panel
     * @param generateAvatarMeshRequest  (optional)
     * @return ApiResponse<GenerateAvatarMeshResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun generateAvatarMeshWithHttpInfo(generateAvatarMeshRequest: GenerateAvatarMeshRequest?) : ApiResponse<GenerateAvatarMeshResult?> {
        val localVariableConfig = generateAvatarMeshRequestConfig(generateAvatarMeshRequest = generateAvatarMeshRequest)

        return request<GenerateAvatarMeshRequest, GenerateAvatarMeshResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation generateAvatarMesh
     *
     * @param generateAvatarMeshRequest  (optional)
     * @return RequestConfig
     */
    fun generateAvatarMeshRequestConfig(generateAvatarMeshRequest: GenerateAvatarMeshRequest?) : RequestConfig<GenerateAvatarMeshRequest> {
        val localVariableBody = generateAvatarMeshRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/GenerateAvatarMesh",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Avatar Presets
     * Get all avatar presets
     * @return GetAvatarPresetsResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAvatarPresets(status: kotlin.Int, Gender: kotlin.Int) : GetAvatarPresetsResult {
        val localVarResponse = getAvatarPresetsWithHttpInfo(status,Gender)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAvatarPresetsResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Avatar Presets
     * Get all avatar presets
     * @return ApiResponse<GetAvatarPresetsResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAvatarPresetsWithHttpInfo(status: kotlin.Int, Gender: kotlin.Int) : ApiResponse<GetAvatarPresetsResult?> {
        val localVariableConfig = getAvatarPresetsRequestConfig(status, Gender)

        return request<Unit, GetAvatarPresetsResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAvatarPresets
     *
     * @return RequestConfig
     */
    fun getAvatarPresetsRequestConfig(status: kotlin.Int, Gender: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("Status", listOf(status.toString()))
                put("Gender", listOf(Gender.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetAvatarPresets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Avatar Presets By ID
     * Retrive Avatar preset by ID
     * @param avatarPresetID Unique Identifier for the Avatar Preset which is being requested
     * @return GetAvatarPresetByIDRequest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAvatarPresetsByID(avatarPresetID: kotlin.String) : GetAvatarPresetByIDRequest {
        val localVarResponse = getAvatarPresetsByIDWithHttpInfo(avatarPresetID = avatarPresetID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAvatarPresetByIDRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Avatar Presets By ID
     * Retrive Avatar preset by ID
     * @param avatarPresetID Unique Identifier for the Avatar Preset which is being requested
     * @return ApiResponse<GetAvatarPresetByIDRequest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAvatarPresetsByIDWithHttpInfo(avatarPresetID: kotlin.String) : ApiResponse<GetAvatarPresetByIDRequest?> {
        val localVariableConfig = getAvatarPresetsByIDRequestConfig(avatarPresetID = avatarPresetID)

        return request<Unit, GetAvatarPresetByIDRequest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAvatarPresetsByID
     *
     * @param avatarPresetID Unique Identifier for the Avatar Preset which is being requested
     * @return RequestConfig
     */
    fun getAvatarPresetsByIDRequestConfig(avatarPresetID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("AvatarPresetID", listOf(avatarPresetID.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetAvatarPresetsByID",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Clips
     * Get all the clips by Active status
     * @param status Status of the clips
     * @return GetClipsResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getClips(status: kotlin.Int) : GetClipsResult {
        val localVarResponse = getClipsWithHttpInfo(status = status)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetClipsResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Clips
     * Get all the clips by Active status
     * @param status Status of the clips
     * @return ApiResponse<GetClipsResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getClipsWithHttpInfo(status: kotlin.Int) : ApiResponse<GetClipsResult?> {
        val localVariableConfig = getClipsRequestConfig(status = status)

        return request<Unit, GetClipsResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getClips
     *
     * @param status Status of the clips
     * @return RequestConfig
     */
    fun getClipsRequestConfig(status: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("Status", listOf(status.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetClips",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Clips By ID
     * Get the specified clip&#39;s details by providing ClipID
     * @param clipID Unique Identifier for the clip
     * @return GetClipsByIDResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getClipsByID(clipID: kotlin.String) : GetClipsByIDResult {
        val localVarResponse = getClipsByIDWithHttpInfo(clipID = clipID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetClipsByIDResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Clips By ID
     * Get the specified clip&#39;s details by providing ClipID
     * @param clipID Unique Identifier for the clip
     * @return ApiResponse<GetClipsByIDResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getClipsByIDWithHttpInfo(clipID: kotlin.String) : ApiResponse<GetClipsByIDResult?> {
        val localVariableConfig = getClipsByIDRequestConfig(clipID = clipID)

        return request<Unit, GetClipsByIDResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getClipsByID
     *
     * @param clipID Unique Identifier for the clip
     * @return RequestConfig
     */
    fun getClipsByIDRequestConfig(clipID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("ClipID", listOf(clipID.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetClipsByID",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Expression By ID
     * Get the specified expression details by providing ExpressionID
     * @param expressionID Unique Identifier for the expression
     * @return GetExpressionByIDResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExpressionByID(expressionID: kotlin.String) : GetExpressionByIDResult {
        val localVarResponse = getExpressionByIDWithHttpInfo(expressionID = expressionID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetExpressionByIDResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Expression By ID
     * Get the specified expression details by providing ExpressionID
     * @param expressionID Unique Identifier for the expression
     * @return ApiResponse<GetExpressionByIDResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExpressionByIDWithHttpInfo(expressionID: kotlin.String) : ApiResponse<GetExpressionByIDResult?> {
        val localVariableConfig = getExpressionByIDRequestConfig(expressionID = expressionID)

        return request<Unit, GetExpressionByIDResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getExpressionByID
     *
     * @param expressionID Unique Identifier for the expression
     * @return RequestConfig
     */
    fun getExpressionByIDRequestConfig(expressionID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("ExpressionID", listOf(expressionID.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetExpressionByID",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Expressions
     * Get all the active expressions
     * @param status Status of Expressions
     * @return GetExpressionsResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExpressions(status: kotlin.Int) : GetExpressionsResult {
        val localVarResponse = getExpressionsWithHttpInfo(status = status)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetExpressionsResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Expressions
     * Get all the active expressions
     * @param status Status of Expressions
     * @return ApiResponse<GetExpressionsResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExpressionsWithHttpInfo(status: kotlin.Int) : ApiResponse<GetExpressionsResult?> {
        val localVariableConfig = getExpressionsRequestConfig(status = status)

        return request<Unit, GetExpressionsResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getExpressions
     *
     * @param status Status of Expressions
     * @return RequestConfig
     */
    fun getExpressionsRequestConfig(status: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("Status", listOf(status.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetExpressions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get All Bucket Vertices
     * Get vertices for all buckets
     * @param platform Name of the platform. I.e. Unreal, Unity
     * @return GetAllBucketVerticesResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGetallbucketvertices(platform: kotlin.String) : GetAllBucketVerticesResult {
        val localVarResponse = getGetallbucketverticesWithHttpInfo(platform = platform)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAllBucketVerticesResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get All Bucket Vertices
     * Get vertices for all buckets
     * @param platform Name of the platform. I.e. Unreal, Unity
     * @return ApiResponse<GetAllBucketVerticesResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGetallbucketverticesWithHttpInfo(platform: kotlin.String) : ApiResponse<GetAllBucketVerticesResult?> {
        val localVariableConfig = getGetallbucketverticesRequestConfig(platform = platform)

        return request<Unit, GetAllBucketVerticesResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGetallbucketvertices
     *
     * @param platform Name of the platform. I.e. Unreal, Unity
     * @return RequestConfig
     */
    fun getGetallbucketverticesRequestConfig(platform: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("Platform", listOf(platform.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetAllBucketVertices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Grant Avatar Preset Items To User
     *
     * @param grantAvatarPresetItemsToUserRequest Request payload (optional)
     * @return GrantAvatarPresetItemsToUserResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun grantAvatarPresetItemsToUser(grantAvatarPresetItemsToUserRequest: GrantAvatarPresetItemsToUserRequest? = null) : GrantAvatarPresetItemsToUserResult {
        val localVarResponse = grantAvatarPresetItemsToUserWithHttpInfo(grantAvatarPresetItemsToUserRequest = grantAvatarPresetItemsToUserRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GrantAvatarPresetItemsToUserResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Grant Avatar Preset Items To User
     *
     * @param grantAvatarPresetItemsToUserRequest Request payload (optional)
     * @return ApiResponse<GrantAvatarPresetItemsToUserResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun grantAvatarPresetItemsToUserWithHttpInfo(grantAvatarPresetItemsToUserRequest: GrantAvatarPresetItemsToUserRequest?) : ApiResponse<GrantAvatarPresetItemsToUserResult?> {
        val localVariableConfig = grantAvatarPresetItemsToUserRequestConfig(grantAvatarPresetItemsToUserRequest = grantAvatarPresetItemsToUserRequest)

        return request<GrantAvatarPresetItemsToUserRequest, GrantAvatarPresetItemsToUserResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation grantAvatarPresetItemsToUser
     *
     * @param grantAvatarPresetItemsToUserRequest Request payload (optional)
     * @return RequestConfig
     */
    fun grantAvatarPresetItemsToUserRequestConfig(grantAvatarPresetItemsToUserRequest: GrantAvatarPresetItemsToUserRequest?) : RequestConfig<GrantAvatarPresetItemsToUserRequest> {
        val localVariableBody = grantAvatarPresetItemsToUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/GrantAvatarPresetItemsToUser",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Grant Avatar Preset To User
     *
     * @param grantAvatarPresetToUserRequest  (optional)
     * @return GrantAvatarPresetToUserResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun grantAvatarPresetToUser(grantAvatarPresetToUserRequest: GrantAvatarPresetToUserRequest? = null) : GrantAvatarPresetToUserResult {
        val localVarResponse = grantAvatarPresetToUserWithHttpInfo(grantAvatarPresetToUserRequest = grantAvatarPresetToUserRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GrantAvatarPresetToUserResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Grant Avatar Preset To User
     *
     * @param grantAvatarPresetToUserRequest  (optional)
     * @return ApiResponse<GrantAvatarPresetToUserResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun grantAvatarPresetToUserWithHttpInfo(grantAvatarPresetToUserRequest: GrantAvatarPresetToUserRequest?) : ApiResponse<GrantAvatarPresetToUserResult?> {
        val localVariableConfig = grantAvatarPresetToUserRequestConfig(grantAvatarPresetToUserRequest = grantAvatarPresetToUserRequest)

        return request<GrantAvatarPresetToUserRequest, GrantAvatarPresetToUserResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation grantAvatarPresetToUser
     *
     * @param grantAvatarPresetToUserRequest  (optional)
     * @return RequestConfig
     */
    fun grantAvatarPresetToUserRequestConfig(grantAvatarPresetToUserRequest: GrantAvatarPresetToUserRequest?) : RequestConfig<GrantAvatarPresetToUserRequest> {
        val localVariableBody = grantAvatarPresetToUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/GrantAvatarPresetToUser",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Render Avatar Image
     *
     * @param renderAvatarImageRequest  (optional)
     * @return RenderAvatarImageResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun renderAvatarImage(renderAvatarImageRequest: RenderAvatarImageRequest? = null) : RenderAvatarImageResult {
        val localVarResponse = renderAvatarImageWithHttpInfo(renderAvatarImageRequest = renderAvatarImageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RenderAvatarImageResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Render Avatar Image
     *
     * @param renderAvatarImageRequest  (optional)
     * @return ApiResponse<RenderAvatarImageResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun renderAvatarImageWithHttpInfo(renderAvatarImageRequest: RenderAvatarImageRequest?) : ApiResponse<RenderAvatarImageResult?> {
        val localVariableConfig = renderAvatarImageRequestConfig(renderAvatarImageRequest = renderAvatarImageRequest)

        return request<RenderAvatarImageRequest, RenderAvatarImageResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation renderAvatarImage
     *
     * @param renderAvatarImageRequest  (optional)
     * @return RequestConfig
     */
    fun renderAvatarImageRequestConfig(renderAvatarImageRequest: RenderAvatarImageRequest?) : RequestConfig<RenderAvatarImageRequest> {
        val localVariableBody = renderAvatarImageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/RenderAvatarImage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Sync Avatars
     * Creates missing avatars into the mentioned platform for the user
     * @param syncAvatarsRequest  (optional)
     * @return SyncAvatarsResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun syncAvatars(syncAvatarsRequest: SyncAvatarsRequest? = null) : SyncAvatarsResult {
        val localVarResponse = syncAvatarsWithHttpInfo(syncAvatarsRequest = syncAvatarsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SyncAvatarsResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Sync Avatars
     * Creates missing avatars into the mentioned platform for the user
     * @param syncAvatarsRequest  (optional)
     * @return ApiResponse<SyncAvatarsResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun syncAvatarsWithHttpInfo(syncAvatarsRequest: SyncAvatarsRequest?) : ApiResponse<SyncAvatarsResult?> {
        val localVariableConfig = syncAvatarsRequestConfig(syncAvatarsRequest = syncAvatarsRequest)

        return request<SyncAvatarsRequest, SyncAvatarsResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation syncAvatars
     *
     * @param syncAvatarsRequest  (optional)
     * @return RequestConfig
     */
    fun syncAvatarsRequestConfig(syncAvatarsRequest: SyncAvatarsRequest?) : RequestConfig<SyncAvatarsRequest> {
        val localVariableBody = syncAvatarsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/SyncAvatars",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
