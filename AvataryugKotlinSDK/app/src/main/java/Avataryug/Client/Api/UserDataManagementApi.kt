/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.Avataryug.client.Apis

import Avataryug.Client.AvatarProjectSettings
import com.Avataryug.client.Infrastructure.ApiClient
import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.Avataryug.client.Models.AddUserAvatarRequest
import com.Avataryug.client.Models.AddUserAvatarResult
import com.Avataryug.client.Models.AddVirtualCurrencyToUserRequest
import com.Avataryug.client.Models.AddVirtualCurrencyToUserResult
import com.Avataryug.client.Models.ConfirmPurchaseRequest
import com.Avataryug.client.Models.ConfirmPurchaseResult
import com.Avataryug.client.Models.ConsumeInstanceRequest
import com.Avataryug.client.Models.ConsumeInstanceResult
import com.Avataryug.client.Models.DeleteUserAvatarResult
import com.Avataryug.client.Models.GetPurchaseResult
import com.Avataryug.client.Models.GetUserInventoryResult
import com.Avataryug.client.Models.GetUsersAllAvatarsResult
import com.Avataryug.client.Models.GrantInstanceToUserRequest
import com.Avataryug.client.Models.GrantInstanceToUserResult
import com.Avataryug.client.Models.PayForPurchaseRequest
import com.Avataryug.client.Models.PayForPurchaseResult
import com.Avataryug.client.Models.PurchaseInstanceRequest
import com.Avataryug.client.Models.PurchaseInstanceResult
import com.Avataryug.client.Models.SubtractUserVirtualCurrencyRequest
import com.Avataryug.client.Models.SubtractUserVirtualCurrencyResult
import com.Avataryug.client.Models.UnlockContainerInstanceRequest
import com.Avataryug.client.Models.UnlockContainerInstanceResult
import com.Avataryug.client.Models.UpdateUserAvatarRequest
import com.Avataryug.client.Models.UpdateUserAvatarResult

import com.Avataryug.client.Infrastructure.ApiResponse
import com.Avataryug.client.Infrastructure.ClientException
import com.Avataryug.client.Infrastructure.ClientError
import com.Avataryug.client.Infrastructure.ServerException
import com.Avataryug.client.Infrastructure.ServerError
import com.Avataryug.client.Infrastructure.MultiValueMap
import com.Avataryug.client.Infrastructure.RequestConfig
import com.Avataryug.client.Infrastructure.RequestMethod
import com.Avataryug.client.Infrastructure.ResponseType
import com.Avataryug.client.Infrastructure.Success

/**
 * Represents a collection of functions to interact with the API endpoints
 */
class UserDataManagementApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            val id = AvatarProjectSettings.Project_Id
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://$id.avataryugapi.com/client")
        }
    }

    /**
     * Add User Avatar
     * Add Avatar to the user
     * @param addUserAvatarRequest  (optional)
     * @return AddUserAvatarResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addUserAvatar(addUserAvatarRequest: AddUserAvatarRequest? = null) : AddUserAvatarResult {
        val localVarResponse = addUserAvatarWithHttpInfo(addUserAvatarRequest = addUserAvatarRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddUserAvatarResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add User Avatar
     * Add Avatar to the user
     * @param addUserAvatarRequest  (optional)
     * @return ApiResponse<AddUserAvatarResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addUserAvatarWithHttpInfo(addUserAvatarRequest: AddUserAvatarRequest?) : ApiResponse<AddUserAvatarResult?> {
        val localVariableConfig = addUserAvatarRequestConfig(addUserAvatarRequest = addUserAvatarRequest)

        return request<AddUserAvatarRequest, AddUserAvatarResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addUserAvatar
     *
     * @param addUserAvatarRequest  (optional)
     * @return RequestConfig
     */
    fun addUserAvatarRequestConfig(addUserAvatarRequest: AddUserAvatarRequest?) : RequestConfig<AddUserAvatarRequest> {
        val localVariableBody = addUserAvatarRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/AddUserAvatar",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Add Virtual Currency to User
     * Increments the user&#39;s balance of the specified virtual currency by the stated amount
     * @param addVirtualCurrencyToUserRequest  (optional)
     * @return AddVirtualCurrencyToUserResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addVirtualCurrencyToUser(addVirtualCurrencyToUserRequest: AddVirtualCurrencyToUserRequest? = null) : AddVirtualCurrencyToUserResult {
        val localVarResponse = addVirtualCurrencyToUserWithHttpInfo(addVirtualCurrencyToUserRequest = addVirtualCurrencyToUserRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddVirtualCurrencyToUserResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add Virtual Currency to User
     * Increments the user&#39;s balance of the specified virtual currency by the stated amount
     * @param addVirtualCurrencyToUserRequest  (optional)
     * @return ApiResponse<AddVirtualCurrencyToUserResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addVirtualCurrencyToUserWithHttpInfo(addVirtualCurrencyToUserRequest: AddVirtualCurrencyToUserRequest?) : ApiResponse<AddVirtualCurrencyToUserResult?> {
        val localVariableConfig = addVirtualCurrencyToUserRequestConfig(addVirtualCurrencyToUserRequest = addVirtualCurrencyToUserRequest)

        return request<AddVirtualCurrencyToUserRequest, AddVirtualCurrencyToUserResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addVirtualCurrencyToUser
     *
     * @param addVirtualCurrencyToUserRequest  (optional)
     * @return RequestConfig
     */
    fun addVirtualCurrencyToUserRequestConfig(addVirtualCurrencyToUserRequest: AddVirtualCurrencyToUserRequest?) : RequestConfig<AddVirtualCurrencyToUserRequest> {
        val localVariableBody = addVirtualCurrencyToUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/AddVirtualCurrencyToUser",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Confirm Purchase
     * Confirms with the payment provider that the purchase was approved (if applicable) and adjusts inventory and virtual currency balances as appropriate
     * @param confirmPurchaseRequest  (optional)
     * @return ConfirmPurchaseResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun confirmPurchase(confirmPurchaseRequest: ConfirmPurchaseRequest? = null) : ConfirmPurchaseResult {
        val localVarResponse = confirmPurchaseWithHttpInfo(confirmPurchaseRequest = confirmPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConfirmPurchaseResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Confirm Purchase
     * Confirms with the payment provider that the purchase was approved (if applicable) and adjusts inventory and virtual currency balances as appropriate
     * @param confirmPurchaseRequest  (optional)
     * @return ApiResponse<ConfirmPurchaseResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun confirmPurchaseWithHttpInfo(confirmPurchaseRequest: ConfirmPurchaseRequest?) : ApiResponse<ConfirmPurchaseResult?> {
        val localVariableConfig = confirmPurchaseRequestConfig(confirmPurchaseRequest = confirmPurchaseRequest)

        return request<ConfirmPurchaseRequest, ConfirmPurchaseResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation confirmPurchase
     *
     * @param confirmPurchaseRequest  (optional)
     * @return RequestConfig
     */
    fun confirmPurchaseRequestConfig(confirmPurchaseRequest: ConfirmPurchaseRequest?) : RequestConfig<ConfirmPurchaseRequest> {
        val localVariableBody = confirmPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ConfirmPurchase",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Consume Instance
     * Consume uses of a consumable item. When all uses are consumed, it will be removed from the user&#39;s inventory.
     * @param consumeInstanceRequest  (optional)
     * @return ConsumeInstanceResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun consumeInstance(consumeInstanceRequest: ConsumeInstanceRequest? = null) : ConsumeInstanceResult {
        val localVarResponse = consumeInstanceWithHttpInfo(consumeInstanceRequest = consumeInstanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConsumeInstanceResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Consume Instance
     * Consume uses of a consumable item. When all uses are consumed, it will be removed from the user&#39;s inventory.
     * @param consumeInstanceRequest  (optional)
     * @return ApiResponse<ConsumeInstanceResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun consumeInstanceWithHttpInfo(consumeInstanceRequest: ConsumeInstanceRequest?) : ApiResponse<ConsumeInstanceResult?> {
        val localVariableConfig = consumeInstanceRequestConfig(consumeInstanceRequest = consumeInstanceRequest)

        return request<ConsumeInstanceRequest, ConsumeInstanceResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation consumeInstance
     *
     * @param consumeInstanceRequest  (optional)
     * @return RequestConfig
     */
    fun consumeInstanceRequestConfig(consumeInstanceRequest: ConsumeInstanceRequest?) : RequestConfig<ConsumeInstanceRequest> {
        val localVariableBody = consumeInstanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ConsumeInstance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete User Avatar
     * Delete specified Avatar for the user
     * @param avatarID Unique Identifier of the Avatar which needs to be deleted
     * @return DeleteUserAvatarResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteUserAvatar(avatarID: kotlin.String) : DeleteUserAvatarResult {
        val localVarResponse = deleteUserAvatarWithHttpInfo(avatarID = avatarID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteUserAvatarResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete User Avatar
     * Delete specified Avatar for the user
     * @param avatarID Unique Identifier of the Avatar which needs to be deleted
     * @return ApiResponse<DeleteUserAvatarResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteUserAvatarWithHttpInfo(avatarID: kotlin.String) : ApiResponse<DeleteUserAvatarResult?> {
        val localVariableConfig = deleteUserAvatarRequestConfig(avatarID = avatarID)

        return request<Unit, DeleteUserAvatarResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteUserAvatar
     *
     * @param avatarID Unique Identifier of the Avatar which needs to be deleted
     * @return RequestConfig
     */
    fun deleteUserAvatarRequestConfig(avatarID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("AvatarID", listOf(avatarID.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/DeleteUserAvatar",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Purchase
     * Retrieves a purchase along with its current AvatarYug status. Returns inventory items from the purchase that are still active.
     * @return GetPurchaseResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPurchase() : GetPurchaseResult {
        val localVarResponse = getPurchaseWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPurchaseResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Purchase
     * Retrieves a purchase along with its current AvatarYug status. Returns inventory items from the purchase that are still active.
     * @return ApiResponse<GetPurchaseResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPurchaseWithHttpInfo() : ApiResponse<GetPurchaseResult?> {
        val localVariableConfig = getPurchaseRequestConfig()

        return request<Unit, GetPurchaseResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPurchase
     *
     * @return RequestConfig
     */
    fun getPurchaseRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetPurchase",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get User Inventory
     * Retrieves the user&#39;s current inventory of virtual goods
     * @param userID Unique AvatarYug identifier of the user whose info is being requested. Optional, defaults to the authenticated user if no other lookup identifier set. (optional)
     * @return GetUserInventoryResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserInventory(userID: kotlin.String? = null) : GetUserInventoryResult {
        val localVarResponse = getUserInventoryWithHttpInfo(userID = userID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUserInventoryResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get User Inventory
     * Retrieves the user&#39;s current inventory of virtual goods
     * @param userID Unique AvatarYug identifier of the user whose info is being requested. Optional, defaults to the authenticated user if no other lookup identifier set. (optional)
     * @return ApiResponse<GetUserInventoryResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserInventoryWithHttpInfo(userID: kotlin.String?) : ApiResponse<GetUserInventoryResult?> {
        val localVariableConfig = getUserInventoryRequestConfig(userID = userID)

        return request<Unit, GetUserInventoryResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserInventory
     *
     * @param userID Unique AvatarYug identifier of the user whose info is being requested. Optional, defaults to the authenticated user if no other lookup identifier set. (optional)
     * @return RequestConfig
     */
    fun getUserInventoryRequestConfig(userID: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (userID != null) {
                    put("UserID", listOf(userID.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetUserInventory",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Users All Avatars
     * Lists all of the avatars that belong to a specific user
     * @param userID Unique AvatarYug assigned ID of the user on whom the operation will be performed
     * @return GetUsersAllAvatarsResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUsersAllAvatars(userID: kotlin.String) : GetUsersAllAvatarsResult {
        val localVarResponse = getUsersAllAvatarsWithHttpInfo(userID = userID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUsersAllAvatarsResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Users All Avatars
     * Lists all of the avatars that belong to a specific user
     * @param userID Unique AvatarYug assigned ID of the user on whom the operation will be performed
     * @return ApiResponse<GetUsersAllAvatarsResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUsersAllAvatarsWithHttpInfo(userID: kotlin.String) : ApiResponse<GetUsersAllAvatarsResult?> {
        val localVariableConfig = getUsersAllAvatarsRequestConfig(userID = userID)

        return request<Unit, GetUsersAllAvatarsResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUsersAllAvatars
     *
     * @param userID Unique AvatarYug assigned ID of the user on whom the operation will be performed
     * @return RequestConfig
     */
    fun getUsersAllAvatarsRequestConfig(userID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("UserID", listOf(userID.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/GetUsersAllAvatars",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Grant Items To User
     * Adds the specified items to the specified user&#39;s inventory
     * @param grantInstanceToUserRequest  (optional)
     * @return GrantInstanceToUserResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun grantInstanceToUser(grantInstanceToUserRequest: GrantInstanceToUserRequest? = null) : GrantInstanceToUserResult {
        val localVarResponse = grantInstanceToUserWithHttpInfo(grantInstanceToUserRequest = grantInstanceToUserRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GrantInstanceToUserResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Grant Items To User
     * Adds the specified items to the specified user&#39;s inventory
     * @param grantInstanceToUserRequest  (optional)
     * @return ApiResponse<GrantInstanceToUserResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun grantInstanceToUserWithHttpInfo(grantInstanceToUserRequest: GrantInstanceToUserRequest?) : ApiResponse<GrantInstanceToUserResult?> {
        val localVariableConfig = grantInstanceToUserRequestConfig(grantInstanceToUserRequest = grantInstanceToUserRequest)

        return request<GrantInstanceToUserRequest, GrantInstanceToUserResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation grantInstanceToUser
     *
     * @param grantInstanceToUserRequest  (optional)
     * @return RequestConfig
     */
    fun grantInstanceToUserRequestConfig(grantInstanceToUserRequest: GrantInstanceToUserRequest?) : RequestConfig<GrantInstanceToUserRequest> {
        val localVariableBody = grantInstanceToUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/GrantInstanceToUser",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Pay For Purchase
     *
     * @param payForPurchaseRequest Selects a payment option for purchase order created via StartPurchase (optional)
     * @return PayForPurchaseResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun payForPurchase(payForPurchaseRequest: PayForPurchaseRequest? = null) : PayForPurchaseResult {
        val localVarResponse = payForPurchaseWithHttpInfo(payForPurchaseRequest = payForPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PayForPurchaseResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pay For Purchase
     *
     * @param payForPurchaseRequest Selects a payment option for purchase order created via StartPurchase (optional)
     * @return ApiResponse<PayForPurchaseResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun payForPurchaseWithHttpInfo(payForPurchaseRequest: PayForPurchaseRequest?) : ApiResponse<PayForPurchaseResult?> {
        val localVariableConfig = payForPurchaseRequestConfig(payForPurchaseRequest = payForPurchaseRequest)

        return request<PayForPurchaseRequest, PayForPurchaseResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation payForPurchase
     *
     * @param payForPurchaseRequest Selects a payment option for purchase order created via StartPurchase (optional)
     * @return RequestConfig
     */
    fun payForPurchaseRequestConfig(payForPurchaseRequest: PayForPurchaseRequest?) : RequestConfig<PayForPurchaseRequest> {
        val localVariableBody = payForPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/PayForPurchase",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Purchase Instance
     * Buys a single item with virtual currency. You must specify both the virtual currency to use to purchase, as well as what the client believes the price to be. This lets the server fail the purchase if the price has changed.
     * @param purchaseInstanceRequest  (optional)
     * @return PurchaseInstanceResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun purchaseInstance(purchaseInstanceRequest: PurchaseInstanceRequest? = null) : PurchaseInstanceResult {
        val localVarResponse = purchaseInstanceWithHttpInfo(purchaseInstanceRequest = purchaseInstanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PurchaseInstanceResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Purchase Instance
     * Buys a single item with virtual currency. You must specify both the virtual currency to use to purchase, as well as what the client believes the price to be. This lets the server fail the purchase if the price has changed.
     * @param purchaseInstanceRequest  (optional)
     * @return ApiResponse<PurchaseInstanceResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun purchaseInstanceWithHttpInfo(purchaseInstanceRequest: PurchaseInstanceRequest?) : ApiResponse<PurchaseInstanceResult?> {
        val localVariableConfig = purchaseInstanceRequestConfig(purchaseInstanceRequest = purchaseInstanceRequest)

        return request<PurchaseInstanceRequest, PurchaseInstanceResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation purchaseInstance
     *
     * @param purchaseInstanceRequest  (optional)
     * @return RequestConfig
     */
    fun purchaseInstanceRequestConfig(purchaseInstanceRequest: PurchaseInstanceRequest?) : RequestConfig<PurchaseInstanceRequest> {
        val localVariableBody = purchaseInstanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/PurchaseInstance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Start Purchase
     * Creates an order for a list of items that needs to be purchased
     * @param body  (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun startPurchase(body: kotlin.Any? = null) : kotlin.Any {
        val localVarResponse = startPurchaseWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Start Purchase
     * Creates an order for a list of items that needs to be purchased
     * @param body  (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun startPurchaseWithHttpInfo(body: kotlin.Any?) : ApiResponse<Any?> {
        val localVariableConfig = startPurchaseRequestConfig(body = body)

        return request<kotlin.Any, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation startPurchase
     *
     * @param body  (optional)
     * @return RequestConfig
     */
    fun startPurchaseRequestConfig(body: kotlin.Any?) : RequestConfig<Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/StartPurchase",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Subtract User Virtual Currency
     * Decrements the user&#39;s balance of the specified virtual currency by the stated amount. It is possible to make a VC balance negative with this API.
     * @param subtractUserVirtualCurrencyRequest  (optional)
     * @return SubtractUserVirtualCurrencyResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun subtractUserVirtualCurrency(subtractUserVirtualCurrencyRequest: SubtractUserVirtualCurrencyRequest? = null) : SubtractUserVirtualCurrencyResult {
        val localVarResponse = subtractUserVirtualCurrencyWithHttpInfo(subtractUserVirtualCurrencyRequest = subtractUserVirtualCurrencyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubtractUserVirtualCurrencyResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Subtract User Virtual Currency
     * Decrements the user&#39;s balance of the specified virtual currency by the stated amount. It is possible to make a VC balance negative with this API.
     * @param subtractUserVirtualCurrencyRequest  (optional)
     * @return ApiResponse<SubtractUserVirtualCurrencyResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun subtractUserVirtualCurrencyWithHttpInfo(subtractUserVirtualCurrencyRequest: SubtractUserVirtualCurrencyRequest?) : ApiResponse<SubtractUserVirtualCurrencyResult?> {
        val localVariableConfig = subtractUserVirtualCurrencyRequestConfig(subtractUserVirtualCurrencyRequest = subtractUserVirtualCurrencyRequest)

        return request<SubtractUserVirtualCurrencyRequest, SubtractUserVirtualCurrencyResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation subtractUserVirtualCurrency
     *
     * @param subtractUserVirtualCurrencyRequest  (optional)
     * @return RequestConfig
     */
    fun subtractUserVirtualCurrencyRequestConfig(subtractUserVirtualCurrencyRequest: SubtractUserVirtualCurrencyRequest?) : RequestConfig<SubtractUserVirtualCurrencyRequest> {
        val localVariableBody = subtractUserVirtualCurrencyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/SubtractUserVirtualCurrency",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Unlock Container Instance
     * Opens the specified container, with the specified key (when required), and returns the contents of the opened container. If the container (and key when relevant) are consumable (RemainingUses &gt; 0), their RemainingUses will be decremented, consistent with the operation of ConsumeItem.
     * @param unlockContainerInstanceRequest  (optional)
     * @return UnlockContainerInstanceResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun unlockContainerInstance(unlockContainerInstanceRequest: UnlockContainerInstanceRequest? = null) : UnlockContainerInstanceResult {
        val localVarResponse = unlockContainerInstanceWithHttpInfo(unlockContainerInstanceRequest = unlockContainerInstanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UnlockContainerInstanceResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unlock Container Instance
     * Opens the specified container, with the specified key (when required), and returns the contents of the opened container. If the container (and key when relevant) are consumable (RemainingUses &gt; 0), their RemainingUses will be decremented, consistent with the operation of ConsumeItem.
     * @param unlockContainerInstanceRequest  (optional)
     * @return ApiResponse<UnlockContainerInstanceResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun unlockContainerInstanceWithHttpInfo(unlockContainerInstanceRequest: UnlockContainerInstanceRequest?) : ApiResponse<UnlockContainerInstanceResult?> {
        val localVariableConfig = unlockContainerInstanceRequestConfig(unlockContainerInstanceRequest = unlockContainerInstanceRequest)

        return request<UnlockContainerInstanceRequest, UnlockContainerInstanceResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation unlockContainerInstance
     *
     * @param unlockContainerInstanceRequest  (optional)
     * @return RequestConfig
     */
    fun unlockContainerInstanceRequestConfig(unlockContainerInstanceRequest: UnlockContainerInstanceRequest?) : RequestConfig<UnlockContainerInstanceRequest> {
        val localVariableBody = unlockContainerInstanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/UnlockContainerInstance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update User Avatar
     * Update Avatar for the user
     * @param updateUserAvatarRequest  (optional)
     * @return UpdateUserAvatarResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateUserAvatar(updateUserAvatarRequest: UpdateUserAvatarRequest? = null) : UpdateUserAvatarResult {
        val localVarResponse = updateUserAvatarWithHttpInfo(updateUserAvatarRequest = updateUserAvatarRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UpdateUserAvatarResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update User Avatar
     * Update Avatar for the user
     * @param updateUserAvatarRequest  (optional)
     * @return ApiResponse<UpdateUserAvatarResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateUserAvatarWithHttpInfo(updateUserAvatarRequest: UpdateUserAvatarRequest?) : ApiResponse<UpdateUserAvatarResult?> {
        val localVariableConfig = updateUserAvatarRequestConfig(updateUserAvatarRequest = updateUserAvatarRequest)

        return request<UpdateUserAvatarRequest, UpdateUserAvatarResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateUserAvatar
     *
     * @param updateUserAvatarRequest  (optional)
     * @return RequestConfig
     */
    fun updateUserAvatarRequestConfig(updateUserAvatarRequest: UpdateUserAvatarRequest?) : RequestConfig<UpdateUserAvatarRequest> {
        val localVariableBody = updateUserAvatarRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/UpdateUserAvatar",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
